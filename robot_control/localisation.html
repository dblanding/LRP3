{% extends "robot_control/page.html.j2" %}
{% block title %}Localisation {% endblock %}
{% block content %}
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <button id="start_moving">Start moving</button>
    <button id="stop_moving">Stop moving</button>
    <div>
        <canvas id="poses"></canvas>
    </div>
    <script src="libs/chart.js"></script>
    <script src="libs/chartjs-plugin-datalabels"></script>

    <script type="module">
        import { connect, publish_when_clicked } from './mqtt_client.js';
        let mqttClient = connect();

        publish_when_clicked(mqttClient, "start", "launcher/start", "localisation");
        publish_when_clicked(mqttClient, "stop", "launcher/stop", "localisation");
        publish_when_clicked(mqttClient, "start_moving", "launcher/start", "fixed_distance_avoider");
        publish_when_clicked(mqttClient, "stop_moving", "launcher/stop", "fixed_distance_avoider");
        const data = {
            datasets: [{
                label: 'poses',
                data: [{x: 750, y: 750, theta: 0}],
            }],
            update_pose_data(json_data) {
                const pose_data = JSON.parse(json_data);
                this.datasets[0].data = pose_data.map(
                    raw_pose => ({x: raw_pose[0], y: raw_pose[1], theta: -raw_pose[2] * 180 / Math.PI})
                );
            }
        };

        const mapPlotter = {
            id: 'mapPlotter',
            walls: [],
            scaledWallVertex(vertex, scales) {
                return [
                    scales.x.getPixelForValue(vertex[0]),
                    scales.y.getPixelForValue(vertex[1])
                ]
            },
            drawWalls(ctx, scales) {
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 0, 255, 1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                let scaledVertex = this.scaledWallVertex(this.walls[0], scales);
                ctx.moveTo(scaledVertex[0], scaledVertex[1]);
                for (const vertex of this.walls) {
                    scaledVertex = this.scaledWallVertex(vertex, scales);
                    ctx.lineTo(scaledVertex[0], scaledVertex[1]);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            },
            beforeDraw(chart, args, options) {
                const { ctx, scales } = chart;
                if(this.walls.length==0) {
                    return;
                }
                this.drawWalls(ctx, scales);
            }
        }

        const datalabels = {
            color: 'blue',
            font: {
                size: 24
            },
            padding: 0,
            formatter(value) {
                return '>'
            },
            rotation(ctx) {
                const index = ctx.dataIndex;
                return ctx.dataset.data[index].theta;
            }
        };

        const pose_chart_config = {
            type: 'scatter',
            data: data,
            options: {
                animation: false,
                responsive: true,
                plugins: {
                    datalabels
                },
                scales: {
                    x: {
                        suggestedMin: 0,
                        suggestedMax: 2200,
                    },
                    y: {
                        suggestedMin: 0,
                        suggestedMax: 2000,
                    }
                }
            },
            plugins: [ChartDataLabels, mapPlotter]
        };
        const pose_ctx = document.getElementById('poses').getContext('2d');
        let pose_chart = new Chart(pose_ctx, pose_chart_config);
        
        let awaiting_update = false;
        function triggerChartUpdate()  {
            awaiting_update = true;
            setTimeout(() => {
                awaiting_update = false;
                pose_chart.update();
            }, 0);
        }

        mqttClient.subscribe('localisation/#')
        mqttClient.on('message', (topic, message) => {
            switch (topic) {
                case 'localisation/poses':
                    if (awaiting_update) {
                        return;
                    }
                    data.update_pose_data(message);
                    pose_chart.update();
                    break;
                case 'localisation/map':
                    const payload = JSON.parse(message);
                    mapPlotter.walls = payload.walls;
                    triggerChartUpdate();
                    break;
            }
        });
    </script>
{% endblock %}
